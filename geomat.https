<!doctype html>
<html lang="sk">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mini Geometry Dash — 3 levely + menu + skins</title>
  <style>
    :root{--panel:#0b1220;--muted:#94a3b8}
    html,body{height:100%;margin:0;background:#081126;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial;color:#e6eef8}
    .wrap{display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;gap:12px;padding:18px}
    canvas{background:linear-gradient(#071026,#00111f);border-radius:8px;box-shadow:0 8px 30px rgba(2,6,23,.7);max-width:100%}
    .ui{color:var(--muted);text-align:center}
    button{background:#0f1724;color:#fff;border:none;padding:8px 12px;border-radius:8px;cursor:pointer}
    .menu{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:40}
    .menu-panel{background:linear-gradient(180deg,#071026,#051027);padding:18px;border-radius:12px;box-shadow:0 12px 40px rgba(0,0,0,.6);min-width:360px}
    .menu h1{margin:0 0 8px 0;font-size:20px}
    .levels{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:10px}
    .levels button{flex:1;padding:10px;border-radius:10px}
    .row{display:flex;gap:8px;align-items:center}
    .topbar{position:fixed;top:12px;left:12px;color:var(--muted);z-index:20}
    .status{position:fixed;top:12px;right:12px;color:var(--muted);z-index:20;text-align:right}
    .skins{display:flex;gap:8px;margin-top:10px}
    .skin-btn{width:46px;height:46px;border-radius:8px;border:2px solid transparent;cursor:pointer;display:flex;align-items:center;justify-content:center}
    .skin-btn.selected{outline:2px solid #fff}
    label{font-size:13px;color:var(--muted)}
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="900" height="450"></canvas>
    <div class="ui">
      <div class="controls">Ovládanie: <strong>medzerník / šípka hore / klik / podrž</strong> (držaním budeš opakovane vyskočiť po dopade).</div>
      <div class="footer">Kocka preskakuje cez trojuholníky (nekoliduje). Koliduje iba s kockami. Vyber level a skin v menu.</div>
    </div>
  </div>

  <!-- Menu -->
  <div id="menu" class="menu">
    <div class="menu-panel">
      <h1>Mini Geometry Dash</h1>
      <div style="font-size:13px;color:var(--muted);margin-bottom:10px">Vyber level, skin kocky alebo pokračuj tam, kde si skončil.</div>

      <div class="levels">
        <button data-idx="0">Level 1</button>
        <button data-idx="1">Level 2</button>
        <button data-idx="2">Level 3</button>
      </div>

      <div class="row" style="margin-bottom:8px">
        <button id="continueBtn">Pokračovať</button>
        <button id="showCredits">Info</button>
      </div>

      <div style="margin-top:8px">
        <label>Vyber skin kocky:</label>
        <div class="skins" id="skinsContainer">
          <!-- skiny sa doplnia JS -->
        </div>
      </div>

      <div style="margin-top:10px;color:var(--muted);font-size:13px" id="credits" hidden>Tlačidlo Restart reštartuje aktuálny level. Držanie tlačidla skok spôsobí opakované skákanie po dopade (auto-hop).</div>
    </div>
  </div>

  <div class="topbar">Hráč: kocka • Cieľ: dôjsť na koniec každého levelu</div>
  <div class="status">
    <div>Prejdené: <span id="score">0</span> / <span id="total">0</span> px</div>
    <div>Level: <span id="levelNum">-</span> • Najlepší: <span id="best">0</span></div>
  </div>

<script>
// --- Rozšírená verzia: 3 levely, rôzne farby pozadia podľa levelu, viac skinov pre kocku, lepšie textúry pre objekty, podržanie skok opakuje skoky
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const menuEl = document.getElementById('menu');
const continueBtn = document.getElementById('continueBtn');
const showCredits = document.getElementById('showCredits');
const credits = document.getElementById('credits');
const scoreEl = document.getElementById('score');
const totalEl = document.getElementById('total');
const levelNumEl = document.getElementById('levelNum');
const bestEl = document.getElementById('best');
const skinsContainer = document.getElementById('skinsContainer');
let W = canvas.width, H = canvas.height;

// hráč so skinom
const player = { x: 120, y: H - 60, w: 40, h: 40, vy: 0, gravity: 0.9, jumpPower: -14, onGround: true, skinIndex: 0 };
let particles = [];
let holdingJump = false; // držanie skoku

// skins - jednoduché definície: každý skin má typ a farby
const skins = [
  { id: 0, name: 'Klasika', type: 'solid', color:'#ffd166' },
  { id: 1, name: 'Prúžky', type: 'stripes', color:'#60a5fa' },
  { id: 2, name: 'Gradient', type: 'gradient', color1:'#f97316', color2:'#ef4444' },
  { id: 3, name: 'Neón', type: 'neon', color:'#34d399' }
];

// vyplň menu skinov
function createSkinButtons(){
  skins.forEach((s, i) => {
    const btn = document.createElement('div');
    btn.className = 'skin-btn';
    btn.title = s.name;
    btn.dataset.idx = i;
    btn.style.background = 'transparent';
    btn.style.border = '2px solid rgba(255,255,255,0.06)';
    btn.style.padding = '4px';
    btn.style.boxSizing = 'border-box';

    // náhľad canvas
    const c = document.createElement('canvas'); c.width = 36; c.height = 36; const g = c.getContext('2d');
    drawPlayerPreview(g, 36, 36, s);
    btn.appendChild(c);

    btn.addEventListener('click', () => { selectSkin(i); });
    skinsContainer.appendChild(btn);
  });
}

function selectSkin(idx){ player.skinIndex = idx; // ulož
  // zvýrazni
  [...skinsContainer.children].forEach((b,bi)=> b.classList.toggle('selected', bi===idx));
  localStorage.setItem('gd_selected_skin', idx);
}

function drawPlayerPreview(ctxP, w, h, skin){ ctxP.clearRect(0,0,w,h); const pad=4; const pw=w-pad*2, ph=h-pad*2; // pozadie
  if(skin.type==='solid'){ ctxP.fillStyle = skin.color; ctxP.fillRect(pad,pad,pw,ph); }
  else if(skin.type==='stripes'){ ctxP.fillStyle=skin.color; ctxP.fillRect(pad,pad,pw,ph); ctxP.fillStyle='rgba(255,255,255,0.12)'; for(let x=pad;x<pw;x+=6) ctxP.fillRect(pad+x,pad,3,ph); }
  else if(skin.type==='gradient'){ const g=ctxP.createLinearGradient(0,pad,0,pad+ph); g.addColorStop(0,skin.color1); g.addColorStop(1,skin.color2); ctxP.fillStyle=g; ctxP.fillRect(pad,pad,pw,ph); }
  else if(skin.type==='neon'){ ctxP.fillStyle=skin.color; ctxP.fillRect(pad,pad,pw,ph); ctxP.globalAlpha=0.25; ctxP.fillStyle='#fff'; for(let i=0;i<3;i++){ ctxP.fillRect(pad+4+i*4,pad,1,ph); } ctxP.globalAlpha=1; }
  // outline
  ctxP.strokeStyle='rgba(0,0,0,0.25)'; ctxP.strokeRect(pad,pad,pw,ph);
}

// Parallax
let clouds = []; for(let i=0;i<6;i++) clouds.push({x:Math.random()*W,y:30+Math.random()*120,w:80+Math.random()*120,v:0.3+Math.random()*0.6});

// Stav hry
let running = false; let gameOver = false; let levelComplete = false; let currentLevelIndex = 0;

// Per-level background color schemes (blue, green, yellow)
const levelBackgrounds = [
  { a:'#0b1226', b:'#071c3a' }, // modrý tón
  { a:'#072012', b:'#0b2a14' }, // zelený tón
  { a:'#2b1a04', b:'#4c2e00' }  // žltý/teplý tón
];

// Levely
const levels = [
  { name:'Level 1 — Modrý', length:3600, defs:[{x:500,type:'triangle',w:40,h:40},{x:800,type:'square',w:40,h:40},{x:1100,type:'triangle',w:60,h:50},{x:1400,type:'square',w:50,h:60},{x:2000,type:'square',w:60,h:60},{x:2600,type:'triangle',w:50,h:40},{x:3000,type:'square',w:40,h:80}]},
  { name:'Level 2 — Zelený', length:4800, defs:[{x:400,type:'triangle',w:40,h:40},{x:700,type:'triangle',w:60,h:50},{x:1000,type:'square',w:50,h:50},{x:1300,type:'square',w:60,h:50},{x:1600,type:'triangle',w:40,h:40},{x:1900,type:'square',w:40,h:100},{x:2400,type:'triangle',w:80,h:40},{x:2800,type:'square',w:60,h:60},{x:3400,type:'square',w:40,h:40}]},
  { name:'Level 3 — Žltý', length:6200, defs:[{x:300,type:'triangle',w:50,h:40},{x:600,type:'square',w:40,h:80},{x:900,type:'triangle',w:60,h:50},{x:1200,type:'square',w:60,h:60},{x:1500,type:'square',w:50,h:120},{x:1800,type:'triangle',w:60,h:60},{x:2100,type:'square',w:70,h:50},{x:2600,type:'triangle',w:80,h:40},{x:3200,type:'square',w:60,h:80},{x:3800,type:'square',w:80,h:60}]} 
];

let obstacles = []; let distanceTravelled = 0; let speed = 6;

// UI
document.querySelectorAll('.levels button').forEach(b => b.addEventListener('click', e => startLevel(parseInt(e.currentTarget.dataset.idx,10))));
continueBtn.addEventListener('click', () => startLevel(currentLevelIndex || 0));
showCredits.addEventListener('click', () => { credits.hidden = !credits.hidden; });

function startLevel(idx){ currentLevelIndex = idx; initLevel(idx); menuEl.style.display='none'; running=true; gameOver=false; levelComplete=false; }
function backToMenu(){ menuEl.style.display='flex'; running=false; gameOver=false; levelComplete=false; updateStatus(); }

function initLevel(idx){ const lvl = levels[idx]; obstacles = lvl.defs.map(d => ({ worldX:d.x, x:W + d.x, type:d.type, w:d.w, h:d.h, y: H - (d.h + 20) })); distanceTravelled = 0; speed = 6; player.y = H - 60; player.vy = 0; player.onGround = true; particles = []; scoreEl.textContent = 0; totalEl.textContent = lvl.length; levelNumEl.textContent = (idx+1) + ' - ' + lvl.name; bestEl.textContent = localStorage.getItem('best_lvl_' + idx) || 0; // load skin
  const savedSkin = parseInt(localStorage.getItem('gd_selected_skin') || '0',10); selectSkin(savedSkin);
}

function saveBest(idx,value){ const key = 'best_lvl_' + idx; const prev = parseInt(localStorage.getItem(key) || '0',10); if(value > prev) localStorage.setItem(key, Math.floor(value)); }

function rectsCollide(a,b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }
function spawnParticles(x,y,color,count=8){ for(let i=0;i<count;i++) particles.push({x,y,vx:(Math.random()-0.5)*6,vy:(Math.random()-0.8)*6,life:30,color}); }

// update loop
function update(){ if(!running) return; clouds.forEach(c => { c.x -= c.v * (speed/6); if(c.x + c.w < 0) c.x = W + Math.random()*200; }); player.vy += player.gravity; player.y += player.vy; if(player.y + player.h >= H - 20){ if(player.vy > 1) spawnParticles(player.x + player.w/2, H - 20, getPlayerMainColor()); player.y = H - 20 - player.h; player.vy = 0; player.onGround = true; // auto-hop when holding
    if(holdingJump){ // ak držíš tlačidlo, automaticky znovu vyskoč
      player.vy = player.jumpPower; player.onGround = false; spawnParticles(player.x + player.w/2, player.y + player.h, getPlayerMainColor(), 6);
    }
  } else player.onGround = false;

  obstacles.forEach(o => { o.x -= speed; }); distanceTravelled += speed;
  particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.vy += 0.3; p.life -= 1; }); particles = particles.filter(p => p.life > 0);

  // collisions only with squares
  obstacles.forEach(o => { if(o.type === 'square' && rectsCollide(player, o) && running){ running = false; gameOver = true; spawnParticles(player.x + player.w/2, player.y + player.h/2, '#ff4d6d', 20); } });

  const lvl = levels[currentLevelIndex]; if(distanceTravelled >= lvl.length && !levelComplete && !gameOver){ levelComplete = true; running = false; saveBest(currentLevelIndex, distanceTravelled); }
}

// helper - hlavná farba hráča podľa skinu
function getPlayerMainColor(){ const s = skins[player.skinIndex]; return s ? (s.color || s.color1) : '#ffd166'; }

// draw textured player according to skin
function drawPlayer(){ const s = skins[player.skinIndex]; const x = player.x, y = player.y, w = player.w, h = player.h;
  // base rounded rect
  roundRect(ctx, x, y, w, h, 6); if(s.type === 'solid'){ ctx.fillStyle = s.color; ctx.fill(); }
  else if(s.type === 'stripes'){ const g = ctx.createLinearGradient(x, y, x, y+h); g.addColorStop(0, s.color); g.addColorStop(1, shade(s.color, -20)); ctx.fillStyle = g; ctx.fill(); // stripes
    ctx.save(); ctx.beginPath(); roundRectPath(ctx, x+4, y+4, w-8, h-8, 4); ctx.clip(); ctx.globalAlpha = 0.18; ctx.fillStyle = '#fff'; for(let sx = x-8; sx < x + w; sx += 8){ ctx.fillRect(sx, y, 4, h); } ctx.restore(); }
  else if(s.type === 'gradient'){ const g = ctx.createLinearGradient(x, y, x, y+h); g.addColorStop(0, s.color1); g.addColorStop(1, s.color2); ctx.fillStyle = g; ctx.fill(); // subtle gloss
    ctx.fillStyle = 'rgba(255,255,255,0.06)'; roundRect(ctx, x+4, y+4, w-8, h/2, 4); ctx.fill(); }
  else if(s.type === 'neon'){ const g = ctx.createLinearGradient(x, y, x+w, y); g.addColorStop(0, shade(s.color, 10)); g.addColorStop(1, shade(s.color, -10)); ctx.fillStyle = g; ctx.fill(); // inner glow
    ctx.save(); ctx.shadowColor = s.color; ctx.shadowBlur = 12; ctx.fillStyle = s.color; roundRect(ctx, x+6, y+6, w-12, h-12, 3); ctx.fill(); ctx.restore(); }
  // outline
  ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(0,0,0,0.28)'; roundRectStroke(ctx, x, y, w, h, 6);
  // eye
  ctx.fillStyle = 'rgba(0,0,0,0.22)'; ctx.fillRect(x + w - 14, y + 10, 6, 6);
}

// draw improved textured obstacles
function drawObstacle(o){ if(o.type === 'square'){ // beveled block with stripes and gradient
    const g = ctx.createLinearGradient(o.x, o.y, o.x, o.y + o.h); g.addColorStop(0, '#ff7b7b'); g.addColorStop(1, '#b91c1c'); ctx.fillStyle = g; ctx.fillRect(o.x, o.y, o.w, o.h);
    // bevel
    ctx.fillStyle = 'rgba(255,255,255,0.06)'; ctx.fillRect(o.x+4, o.y+4, o.w-8, 6);
    ctx.fillStyle = 'rgba(0,0,0,0.12)'; ctx.fillRect(o.x+4, o.y + o.h - 10, o.w-8, 8);
    // subtle pattern
    ctx.globalAlpha = 0.08; ctx.fillStyle = '#fff'; for(let i=0;i<o.h;i+=8){ ctx.fillRect(o.x, o.y + i, o.w, 2); } ctx.globalAlpha = 1;
  } else { // triangle with gradient and stroke
    const g = ctx.createLinearGradient(o.x, o.y, o.x, o.y + o.h); g.addColorStop(0, '#60a5fa'); g.addColorStop(1, '#1e40af'); ctx.fillStyle = g; ctx.beginPath(); ctx.moveTo(o.x, o.y + o.h); ctx.lineTo(o.x + o.w/2, o.y); ctx.lineTo(o.x + o.w, o.y + o.h); ctx.closePath(); ctx.fill(); ctx.strokeStyle = 'rgba(0,0,0,0.12)'; ctx.stroke(); }
}

function draw(){ ctx.clearRect(0,0,W,H);
  // dynamic background per level
  const bg = levelBackgrounds[currentLevelIndex] || levelBackgrounds[0];
  const gbg = ctx.createLinearGradient(0,0,0,H); gbg.addColorStop(0, bg.a); gbg.addColorStop(1, bg.b); ctx.fillStyle = gbg; ctx.fillRect(0,0,W,H);

  // clouds
  ctx.globalAlpha = 0.9; clouds.forEach(c => { ctx.fillStyle = 'rgba(200,220,255,0.06)'; ctx.beginPath(); ctx.ellipse(c.x, c.y, c.w, 24, 0,0,Math.PI*2); ctx.fill(); }); ctx.globalAlpha = 1;

  // ground
  ctx.fillStyle = '#071625'; ctx.fillRect(0, H - 20, W, 20); ctx.fillStyle = '#0b3344'; ctx.fillRect(0, H - 20, W, 6);

  // finish flag
  const lvl = levels[currentLevelIndex]; const finishScreenX = W + (lvl.length - distanceTravelled);
  if(finishScreenX > -100 && finishScreenX < W + 200){ ctx.fillStyle = '#fff'; ctx.fillRect(finishScreenX, H - 120, 4, 100); ctx.fillStyle = '#ffd166'; ctx.beginPath(); ctx.moveTo(finishScreenX + 4, H - 120); ctx.lineTo(finishScreenX + 36, H - 108); ctx.lineTo(finishScreenX + 4, H - 96); ctx.closePath(); ctx.fill(); }

  // obstacles
  obstacles.forEach(o => drawObstacle(o));

  // player
  drawPlayer();

  // particles
  particles.forEach(p => { ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, 3, 3); });

  // overlays
  if(gameOver){ ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(0,0,W,H); ctx.fillStyle = '#fff'; ctx.font = '32px system-ui'; ctx.textAlign='center'; ctx.fillText('Game Over', W/2, H/2 - 10); ctx.font = '16px system-ui'; ctx.fillText('Stlač Restart alebo M pre menu', W/2, H/2 + 20); }
  if(levelComplete){ ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(0,0,W,H); ctx.fillStyle = '#fff'; ctx.font = '36px system-ui'; ctx.textAlign='center'; ctx.fillText('Úroveň dokončená!', W/2, H/2 - 30); ctx.font = '18px system-ui'; ctx.fillText('Prešiel si ' + levels[currentLevelIndex].name, W/2, H/2); ctx.font = '14px system-ui'; if(currentLevelIndex < levels.length - 1){ ctx.fillText('Stlač N pre ďalší level alebo M pre menu', W/2, H/2 + 30); } else { ctx.fillText('Prešiel si všetky levely! Stlač M pre menu', W/2, H/2 + 30); } }
}

function loop(){ update(); draw(); requestAnimationFrame(loop); }
requestAnimationFrame(loop);

// helpers for rounded rects
function roundRect(c, x, y, w, h, r){ c.beginPath(); c.moveTo(x + r, y); c.arcTo(x + w, y, x + w, y + h, r); c.arcTo(x + w, y + h, x, y + h, r); c.arcTo(x, y + h, x, y, r); c.arcTo(x, y, x + w, y, r); c.closePath(); }
function roundRectPath(c, x, y, w, h, r){ roundRect(c,x,y,w,h,r); }
function roundRectStroke(c,x,y,w,h,r){ roundRect(c,x,y,w,h,r); c.stroke(); }

// color shade helper
function shade(hex, percent){ const c = hex.replace('#',''); const num = parseInt(c,16); let r = (num >> 16) + percent; let g = ((num >> 8) & 0x00FF) + percent; let b = (num & 0x0000FF) + percent; r = Math.max(0, Math.min(255, r)); g = Math.max(0, Math.min(255, g)); b = Math.max(0, Math.min(255, b)); return '#' + ( (1<<24) + (r<<16) + (g<<8) + b ).toString(16).slice(1); }

// input / controls
function jump(){ if(!running){ if(gameOver){ initLevel(currentLevelIndex); running=true; gameOver=false; levelComplete=false; } return; } if(player.onGround){ player.vy = player.jumpPower; player.onGround = false; spawnParticles(player.x + player.w/2, player.y + player.h, getPlayerMainColor(), 8); } }

window.addEventListener('keydown', e => { if(e.code === 'Space' || e.code === 'ArrowUp'){ e.preventDefault(); if(!holdingJump) holdingJump = true; // start holding
    if(player.onGround && running) jump(); } if(e.key === 'm' || e.key === 'M'){ backToMenu(); } if((e.key === 'n' || e.key === 'N') && levelComplete){ if(currentLevelIndex < levels.length - 1){ startLevel(currentLevelIndex + 1); } } });
window.addEventListener('keyup', e => { if(e.code === 'Space' || e.code === 'ArrowUp'){ holdingJump = false; } });
// pointer for mobile: pointerdown = start hold + immediate jump; pointerup = release
window.addEventListener('pointerdown', e => { holdingJump = true; if(running) jump(); });
window.addEventListener('pointerup', e => { holdingJump = false; });

// skin selection init
createSkinButtons(); const saved = parseInt(localStorage.getItem('gd_selected_skin') || '0',10); selectSkin(saved);

// adapt
(function adapt(){ if(window.innerWidth < 800){ canvas.width = Math.min(900, window.innerWidth - 40); canvas.height = Math.round(canvas.width * 0.5); W = canvas.width; H = canvas.height; } })();

// status update
setInterval(()=>{ scoreEl.textContent = Math.floor(distanceTravelled); const b = localStorage.getItem('best_lvl_' + currentLevelIndex) || 0; bestEl.textContent = b; }, 80);

// show menu on start
backToMenu();
</script>
</body>
</html>
